\documentclass[10pt]{article}
%\usepackage{tex4ht}
\usepackage[OT1,T2A]{fontenc}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[koi8-r]{inputenc}
\usepackage[russian]{babel}

\title{Signaling : Руководство программиста.
       \newline
       \small{DocumentId:GradSoft-PR-27.09.2001-v1.0.2}
      }
% $Id: 

\begin{document}

\maketitle{}

\section{ Введение }
     Компонента \verb|Signaling| предназначена для обработки POSIX сигналов. В POSIX 
системах сигналы используются для обработки неординарных, требующих определенной 
обработки событий. События могут вызываться процессом, пользователем или ядром.
POSIX сигналы являются, в какой-то мере, программной реализацией аппаратных 
прерываний. Множество всех сигналов, используемых в системе, перечислена в header 
файле <signal.h>. В <signal.h> каждый сигнал имеет свое уникальное имя и номер.
Для получения болeе детальной информации о сигналах обратитесь в соответствующие
источники (например для UNIX смотрите {\bf man signal}).

\section{ Общее описание механизма работы. }
     Перед тем как использовать в программе компоненту Signaling для обработки
сигналов необходимо в первую очередь написать их обработчик. Обработчик сигналов
представляет собой определенный класс, наследуемый от абстрактного класса 
{\bf SignalHandler}. Реализация обработчика сигналов должна находиться в 
переопределенном виртуальном методе {\bf void handler(int insignal\_number) }
класса {\bf SignalHandler}.
В этот метод передается единственный параметр: внутренний номер сигнала, 
для которого вызван обработчик. \\
    Обработчик сигналов устанавливается с помощью wrapped 
класса Signaling. Сигнатура конструктор Signaling выглядит следующим образом :
{\bf Signaling( unsigned long  sigset, SignalHandler\& handler )}, где \\
\verb|sigset|   множество обрабатываемых сигналов (см. ниже) и \\
\verb|handler|  класс обработчик сигналов (см. выше).\\
Из-за чисто технических проблем в компоненте Signaling  для  сигналов определяются
собственные имена и номера, отличные от стандартных. Все имена и номера сигналов
описываются в классе SignalSet. Внутренние имена сигналов совпадают со стандартными
именами плюс в начале имени добавляется буква "{s}".\\
{\it
  Внимание: Для компонента Signaling используйте только те константы, которые
  определенны в классе SignalSet.
}\\
Для определения не одного, а множества сигналов используется оператор | "ИЛИ".
Если необходимо задать сразу все сигналы, то можно воспользоваться внутренней
константой SignalSet::sENABLE\_ALL.(из этой константы исключены сигналы, которые
не могут быть перехвачены: SignalSet::sSIGKILL и SignalSet::sSIGSTOP).
Общее число всех сигналов задано константой SignalSet::sNSIG.

\section{ Использование }
Определим сначала обработчик сигнала:
\begin{verbatim}
/* File demo_handler.h */
. . .
class demo_handler : public SignalHandler {
public :
      virtual void handler(int signal) {
        cerr << "Catch signal :" << signal << endl;
      }
}
. . .
\end{verbatim}
Установка обработчика "demo\_handler" для обработки всех сигналов :
\begin{verbatim}
#include <demo_handler.h>
. . .
{
    Signaling(SignalSet::ENABLE_ALL_, demo_handler);
    . . .
}
. . .
\end{verbatim}
Для более детальной информации смотрите директорию \verb|demo| в дистрибутиве.
\section{Требования.}
1. Перед использованием Signaling-а должны быть определены
   макросы {\bf HAVE\_SIGACTION} или {\bf HAVE\_SIGNAL} в зависимости от того,
   какая функция будет использоваться для обработки сигнала {\bf sigaction}
   или {\bf signal}.\\
2. Если компилятор поддерживает \verb|namespace|, то должен быть определен
   макрос {\bf HAVE\_NAMESPACES}.
\end{document}
